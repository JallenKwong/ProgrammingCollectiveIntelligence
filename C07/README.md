# 决策树建模 #

**决策树学习**的自动分类算法——产生的模型具有易于解释的特点。

**贝叶斯分类器**中的数字列表展现每个单词的重要程度，但是你必须经过计算才能知道结果如何。

理解**神经网络**的难度则更大，因为位于两个神经元之间的连接上的权重值本身并没有什么实际意义。

对于**决策树**，只需通过观察便可理解其推导的过程，甚至可转换成一系列if-else语句。

## 预测注册用户 ##

目标：预测一位用户成为付费顾客的可能性有多大

强调算法的清晰直观——若知道哪些因素可表明用户将会成为付费顾客，那么就

1. 可以利用这些信息来指导广告策略制定工作，让网站的某些功能具有更好的可用性；
2. 采取其他能够有效增加付费顾客数量的策略。

---

**情景描述**

假设有一个提供免费试用的在线应用。用户为了获得试用的机会而注册了账号，待使用了若干天之后，他们可以选择向基本服务或高级服务升级。

因为用户为了免费试用须要注册账号，所以可以借此将用户的相关信息收集起来，并且在试用结束的时候，网站的所有者会记录下哪些用户选择了成为付费客户。

为了尽量减少用户的工作量，使其能够尽快地注册账号，网站不会过多地询问用户的个人信息，相反，它会从服务器的日志中收集这些信息，比如:用户来自哪个网站，所在的地理位置，以及他们在注册之前曾经浏览过多少网页，等等。假设我们收集到了这些数据，井且将它们填入一张表格中，其结果可能如下：

![](image/01.png)


	my_data=[['slashdot','USA','yes',18,'None'],
	        ['google','France','yes',23,'Premium'],
	        ['digg','USA','yes',24,'Basic'],
	        ['kiwitobes','France','yes',23,'Basic'],
	        ['google','UK','no',21,'Premium'],
	        ['(direct)','New Zealand','no',12,'None'],
	        ['(direct)','UK','no',21,'Basic'],
	        ['google','USA','no',24,'Premium'],
	        ['slashdot','France','yes',19,'None'],
	        ['digg','USA','no',18,'None'],
	        ['google','UK','no',18,'None'],
	        ['kiwitobes','UK','no',19,'None'],
	        ['digg','New Zealand','yes',12,'Basic'],
	        ['slashdot','UK','no',21,'None'],
	        ['google','UK','yes',18,'Basic'],
	        ['kiwitobes','France','yes',19,'Basic']]

最后一列服务列代表了用户是否已经注册，也是希望预测的内容。 

接下来的目标：找到一个算法，能够将一个合理的推测值填入“服务”栏。

## 引入决策树 ##

![](image/02.png)

一旦有了决策树，据此进行决策的过程就变得非常容易理解了。只要沿着树的路径一直向下，正确回答每一个问题，最终就会得到答案。

沿着最终的叶节点向上回溯，就会得到一个有关最终分类结果的推理过程。

决策树的节点编程

	class decisionnode:
	  def __init__(self,col=-1,value=None,results=None,tb=None,fb=None):
		# 待检测的判断条件 所对应的列索引值。
	    self.col=col

		# value对应于为了使结果为true，当前列必须匹配的值。
	    self.value=value

		# 保存的是针对于当前分支的结果，它是一个字典。除叶节点外，在其他节点上该值都为None。
	    self.results=results

		# 对应于结果分别为true或false时，类似二叉树的左右子树
	    self.tb=tb
	    self.fb=fb


## 对树进行训练 ##

将使用一种叫作CART(Classification and Regression Trees分类回归树)算法。

为了构造决策树，算法首先创建一个根节点。然后通过评估表中的所有观测变量，从中选出最合适的变量对数据进行拆分。为此，算法考查了所有不同的变量，然后从中选出一个条件（如：用户是否读过FAQ?）对结果数据进行分解，以使我们更容易地推出用户的意图来（用户会因哪一项服务而注册账号）。

## 选择最合适的拆分方案 ##


## 以递归方式构造树 ##


## 决策树的相似 ##


## 对新的观测数据进行分类 ##


## 决策树的剪枝 ##


## 处理缺失数据 ##


## 处理数值型结果 ##


## 对住房价格进行建模 ##


## 对“热度”评价进行建模 ##


## 什么时候使用决策树 ##



## 小结 ##
